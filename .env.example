### STJ RAG Automation â€” .env.example

# App settings
NODE_ENV=development
PORT=3000
VITE_APP_ID=your_app_id_here
JWT_SECRET=change_this_to_a_secure_random_value

# Database (MySQL) - used by drizzle
DATABASE_URL=mysql://user:password@host:3306/stj_rag_db

# OAuth / storage / forge proxy
OAUTH_SERVER_URL=https://oauth.example.com
OWNER_OPEN_ID=optional_owner_openid
BUILT_IN_FORGE_API_URL=https://forge.example.com
BUILT_IN_FORGE_API_KEY=your_forge_api_key

# Gemini / embeddings
GEMINI_API_KEY=your_gemini_api_key
GEMINI_EMBED_URL= (optional) override embedding endpoint
GEMINI_BATCH_EMBED_URL= (optional) override batch endpoint
EMBEDDING_DIMENSION=768
EMBEDDING_BATCH_SIZE=50
EMBEDDING_MAX_RETRIES=3
EMBEDDING_RETRY_BASE_MS=300
EMBEDDING_CONCURRENCY=1

# Logging and metrics
LOG_LEVEL=info

# Docker / runtime notes
# Vector store (Qdrant)
# When running Qdrant locally via docker-compose, set QDRANT_URL to the service address and optionally QDRANT_API_KEY
QDRANT_URL=http://qdrant:6333
QDRANT_API_KEY=    # optional: set if Qdrant server requires an API key

# If still using Chroma fallback, set CHROMA_PATH to a writable directory mounted in container
CHROMA_PATH=/data/chroma

# Async batch / GCP (optional)
# To enable async batch embeddings via GCS you need:
# - A GCP project
# - A GCS bucket
# - A Service Account key JSON with roles: Storage Admin (or Storage Object Admin) and appropriate Generative AI permissions
# Set these to enable the `gemini_gcs_batch.ts` script and asyncBatch flow.
GOOGLE_APPLICATION_CREDENTIALS=/secrets/gcp-service-account.json
GCP_PROJECT=your-gcp-project-id
GCP_LOCATION=us-central1
GCP_BUCKET=your-gcs-bucket-for-embeddings

# Supabase (optional) - use if you prefer Supabase Storage instead of GCS for artifacts.
# NOTE: asyncBatchEmbedContent from Gemini requires GCS; Supabase can be used for storage
# of originals/metadata and per-item embedding pipelines.
SUPABASE_URL=https://your-supabase-instance.supabase.co
SUPABASE_SERVICE_KEY=your_supabase_service_key

